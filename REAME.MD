# 面试题汇总
## 分布式唯一ID的生成方案有哪些？
| 方案 | 描述 | 优点 | 缺点 |
| :------| :------: | :------ | :------ |
| UUID | UUID是通用的唯一标识的缩写,它的目的是让分布式系统中的所<br>有元素都唯一的辨识信息，而不是需要中央控制器来指定唯一标<br>识| 1.降低了全军节点的压力，是的主键生成的速度更加的快<br>2.生成的主键全局唯一<br>3.跨服务合并方便 |1. UUID占用16个字符，空间占用比较大<br>2.不是递增性的，数据写入IO随机性很大，且索引效率下降 |
| 数据库主键自增 | MySQL数据库设置主键且主键自动增长 | 1. INT和BIGINT类型占用空间较小<br>2.主键自动增长，IO写入连续性好<br>3.数字类型查询速度优于字符串 |1. 并发性能不高，受限于数据库性能，<br>2.分库，分表，需要改造，复杂<br>3.自增，数据和数据量泄露 |
|  Redis自增 | Redis计数器，原子性自增  | 使用内存，并发性好  |1. 数据丢失，2.自增：数据量泄露  |
|雪花算法| 雪花算法是分布式ID的经典解决方案| 1. 不依赖外部组件，<br>2.性能好 | 时钟回拨|

```text
此处主要推荐使用雪花算法来作为全局唯一ID的方案，雪花算法的全局唯一ID主要有一下几个部分组成：
1. 符号位占1位
2. 时间戳占41位
3. 随机ID占10位
4. 序列号占12位，一毫秒可以生产4095个ID
```

## 使用分布式锁的场景
```text
1. 系统是一个分布式系统，集群，java自带的锁在这种情况下无法处理这个问题
2. 操作共享资源，比如库里唯一的用户数据
3. 同步访问，即多个线程操作共享资源
```

### 分布式锁的解决方案
```text
1. Redis分布式锁，是基于Redis做扩展开发，setnx key vakue expire 
 如果自己写需要考虑锁的时效性(程序突然挂了，但是锁没释放)，锁的设置和过期时间要是原子性的，watchdog(保证不会因为程序执行太长)

2. 基于zookeeper，临时节点，顺序节点

3. 基于数据库，比如MySql主键唯一索引的唯一性
```

### Redis做分布式锁死锁的情况，如何解决
```text
情况1. 加了锁，但是没有加释放锁的操作，如delete key

情况2. 加锁后，程序还没有执行释放锁，程序挂了，需要使用key过期时间
```

### 技术器算法
```text
技术器蒜贩，是指在指定的时间周期内累加访问的次数，达到设定的阈值时，触发的限流策略。下一个时间周期 进行访问，
访问的次数清零，这个算法无论在三级还是分布式环境下实现都非常地简单，使用redis的incr原子自增性，再结合key的过期
时间，即可轻松的实现
```











